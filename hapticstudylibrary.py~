#hapticstudylibrary.py
# Kat Allen 2023 
# kat.allen@tufts.edu

from boto3 import Session
from botocore.exceptions import BotoCoreError, ClientError
from contextlib import closing
import os
import sys
import subprocess
from tempfile import gettempdir
import csv
import armpy.arm
import armpy.gripper
import waypointgathering


def robotintroduction(robotname="Beep"):


    # Create a client using the credentials and region defined in the [default]
    # section of the AWS credentials file (~/.aws/credentials).
    session = Session(profile_name="default")
    polly = session.client("polly")

    introtext = "Hello my name is" + robotname 
    try:
        # Request speech synthesis
        response = polly.synthesize_speech(Text=introtext, OutputFormat="mp3",
                                            VoiceId="Justin") # young-sounding voice
    except (BotoCoreError, ClientError) as error:
        # The service returned an error, exit gracefully
        print(error)
        sys.exit(-1)

    # Access the audio stream from the response
    if "AudioStream" in response:
        # Note: Closing the stream is important because the service throttles on the
        # number of parallel connections. Here we are using contextlib.closing to
        # ensure the close method of the stream object will be called automatically
        # at the end of the with statement's scope.
        with closing(response["AudioStream"]) as stream:
                output = os.path.join(gettempdir(), "speech.mp3")

        try:
            # Open a file for writing the output as a binary stream
                with open(output, "wb") as file:
                    file.write(stream.read())
                print("wrote audio output to ", output)
        except IOError as error:
            # Could not write to file, exit gracefully
            print(error)
            sys.exit(-1)
        return output
    else:
        # The response didn't contain audio data, exit gracefully
        print("Could not stream audio")
        sys.exit(-1)

def create_trajectory_from_waypoints(filename="waypoints.csv"):
    arm = armpy.arm.Arm()

    # filename should be a CSV file, formatted like waypointgathering.py
    print("Loading waypoints from", filename)

    
    with open(filename, 'r') as f:
        filelist = csv.DictReader(f)    
        data = [row for row in filelist]
    
    jointnames = ["j2s7s300_joint_1", "j2s7s300_joint_2", "j2s7s300_joint_3", "j2s7s300_joint_4", "j2s7s300_joint_5", "j2s7s300_joint_6", "j2s7s300_joint_7"]    
    print("Moving to start position")

    arm.move_to_joint_pose(float([data[0][joint]) for joint in jointnames])

    print("Select the points to use in the trajectory")
    while point in filelist: 
        point = str(input())
        waypointlist = waypointlist + point

    print("Generating trajectories from waypoints")
    armpy.plan_waypoints(waypointlist)


        
if __name__=="__main__":
    print("\n\n\n\n")	
    print("This is a library file but here are some things to test\n")
    print("1: gather waypoints\n 2: make trajectory from waypoints q: exit")
    menuchoice = input()	
    if menuchoice =="1": 
        print("Gathering waypoints.  Enter filename (or enter to default to waypoints.csv)")
        filename = input()
        if len(filename)==0:
	        waypointgathering.waypointgathering()
        else:
                waypointgathering.waypointgathering(filename)
    elif menuchoice =="2":
        print("making trajectory from waypoints. Enter filename or enter for default (waypoints.csv)")
        filename = input()
        if len(filename)==0:
                create_trajectory_from_waypoints()
        else:        
                create_trajectory_from_waypoints(filename)
    elif menuchoice =="q":
        exit